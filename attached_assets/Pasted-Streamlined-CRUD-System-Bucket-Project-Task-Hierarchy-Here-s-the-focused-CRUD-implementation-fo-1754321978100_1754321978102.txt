Streamlined CRUD System: Bucket → Project → Task Hierarchy
Here's the focused CRUD implementation for your exact hierarchy:
1. Core Hierarchy Schema
prisma// The essential models for your Bucket → Project → Task structure

model Bucket {
  id                String   @id @default(cuid())
  labId             String   @map("lab_id")
  name              String   // Wisconsin R01, Clinical Studies, RICCC Internal
  description       String?
  color             String   @default("#3B82F6")
  icon              String   @default("folder")
  position          Int      @default(0) // For kanban column ordering
  isActive          Boolean  @default(true) @map("is_active")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  lab               Lab      @relation(fields: [labId], references: [id])
  projects          Project[] // All projects in this bucket

  @@unique([labId, name])
  @@map("buckets")
}

model Project {
  id                String   @id @default(cuid())
  bucketId          String   @map("bucket_id") // MUST belong to a bucket
  name              String
  oraNumber         String?  @unique @map("ora_number")
  
  // Core fields
  status            String   @default("planning")
  projectType       String   @map("project_type") // study, rct, ehr_study, ai_llm
  studyType         String?  @map("study_type") // Interventional, Observational
  priority          String   @default("medium")
  fundingSource     String?  @map("funding_source")
  
  // Additional info
  externalCollaborators String? @db.Text @map("external_collaborators")
  dueDate           DateTime? @map("due_date")
  notes             String?  @db.Text
  
  // File links
  protocolLink      String?  @map("protocol_link")
  dataLink          String?  @map("data_link")
  
  // Positioning in kanban
  position          Int      @default(0)
  isActive          Boolean  @default(true) @map("is_active")
  createdById       String   @map("created_by_id")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  bucket            Bucket   @relation(fields: [bucketId], references: [id])
  createdBy         User     @relation(fields: [createdById], references: [id])
  members           ProjectMember[] // Team members assigned to project
  tasks             Task[]   // All tasks for this project

  @@index([bucketId, position])
  @@map("projects")
}

model Task {
  id                String   @id @default(cuid())
  projectId         String   @map("project_id") // MUST belong to a project
  parentTaskId      String?  @map("parent_task_id") // For subtasks
  
  title             String
  description       String?  @db.Text
  status            String   @default("todo") // todo, in_progress, review, completed
  priority          String   @default("medium")
  dueDate           DateTime? @map("due_date")
  
  // Task organization
  position          Int      @default(0) // Order within project
  tags              String[]
  
  // Completion
  completedAt       DateTime? @map("completed_at")
  completedById     String?   @map("completed_by_id")
  
  isActive          Boolean  @default(true) @map("is_active")
  createdById       String   @map("created_by_id")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  project           Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parentTask        Task?    @relation("TaskSubtasks", fields: [parentTaskId], references: [id])
  subtasks          Task[]   @relation("TaskSubtasks")
  createdBy         User     @relation(fields: [createdById], references: [id])
  assignees         TaskAssignment[] // Can have multiple assignees

  @@index([projectId, position])
  @@index([parentTaskId])
  @@map("tasks")
}

model ProjectMember {
  id                String   @id @default(cuid())
  projectId         String   @map("project_id")
  userId            String   @map("user_id")
  role              String   @default("contributor") // lead, contributor, advisor
  joinedAt          DateTime @default(now()) @map("joined_at")

  // Relations
  project           Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user              User     @relation(fields: [userId], references: [id])

  @@unique([projectId, userId])
  @@map("project_members")
}

model TaskAssignment {
  id                String   @id @default(cuid())
  taskId            String   @map("task_id")
  userId            String   @map("user_id")
  assignedAt        DateTime @default(now()) @map("assigned_at")

  // Relations
  task              Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user              User     @relation(fields: [userId], references: [id])

  @@unique([taskId, userId])
  @@map("task_assignments")
}
2. Bucket CRUD Service
typescript// services/bucket.service.ts
export class BucketService extends BaseService {
  
  // CREATE - New bucket for organizing projects
  async create(data: CreateBucketInput) {
    // Get the next position
    const lastBucket = await this.prisma.bucket.findFirst({
      where: { labId: data.labId },
      orderBy: { position: 'desc' }
    });
    
    const position = (lastBucket?.position ?? -1) + 1;
    
    return this.prisma.bucket.create({
      data: {
        ...data,
        position
      }
    });
  }
  
  // READ - Get all buckets with their projects for kanban view
  async getBucketsWithProjects(labId: string) {
    return this.prisma.bucket.findMany({
      where: { 
        labId,
        isActive: true 
      },
      include: {
        projects: {
          where: { isActive: true },
          include: {
            members: {
              include: { user: true }
            },
            _count: {
              select: {
                tasks: {
                  where: { isActive: true }
                },
                members: true
              }
            },
            tasks: {
              where: { 
                isActive: true,
                parentTaskId: null // Only root tasks
              },
              select: {
                id: true,
                status: true
              }
            }
          },
          orderBy: { position: 'asc' }
        }
      },
      orderBy: { position: 'asc' }
    });
  }
  
  // UPDATE - Reorder buckets
  async reorderBuckets(labId: string, bucketOrder: string[]) {
    const updates = bucketOrder.map((bucketId, index) => 
      this.prisma.bucket.update({
        where: { id: bucketId },
        data: { position: index }
      })
    );
    
    return this.prisma.$transaction(updates);
  }
  
  // DELETE - Soft delete (keeps projects)
  async delete(bucketId: string) {
    // Check if bucket has projects
    const projectCount = await this.prisma.project.count({
      where: { bucketId, isActive: true }
    });
    
    if (projectCount > 0) {
      throw new Error('Cannot delete bucket with active projects');
    }
    
    return this.prisma.bucket.update({
      where: { id: bucketId },
      data: { isActive: false }
    });
  }
}
3. Project CRUD Service
typescript// services/project.service.ts
export class ProjectService extends BaseService {
  
  // CREATE - New project in a bucket
  async create(data: CreateProjectInput) {
    // Validate bucket exists and user has access
    const bucket = await this.prisma.bucket.findFirst({
      where: {
        id: data.bucketId,
        lab: {
          members: {
            some: {
              userId: this.userId,
              isActive: true
            }
          }
        }
      }
    });
    
    if (!bucket) {
      throw new Error('Bucket not found or access denied');
    }
    
    // Get position for new project
    const lastProject = await this.prisma.project.findFirst({
      where: { bucketId: data.bucketId },
      orderBy: { position: 'desc' }
    });
    
    const position = (lastProject?.position ?? -1) + 1;
    
    // Generate ORA number if needed
    const oraNumber = data.oraNumber || await this.generateORANumber();
    
    return this.prisma.$transaction(async (tx) => {
      // Create project
      const project = await tx.project.create({
        data: {
          ...data,
          oraNumber,
          position,
          createdById: this.userId,
          members: {
            create: {
              userId: this.userId,
              role: 'lead'
            }
          }
        },
        include: {
          bucket: true,
          members: {
            include: { user: true }
          }
        }
      });
      
      // Create default tasks based on project type
      if (data.createDefaultTasks) {
        await this.createDefaultTasks(tx, project.id, data.projectType);
      }
      
      return project;
    });
  }
  
  // READ - Get project with all its data
  async getProjectWithTasks(projectId: string) {
    return this.prisma.project.findUnique({
      where: { id: projectId },
      include: {
        bucket: {
          include: { lab: true }
        },
        members: {
          include: { user: true }
        },
        tasks: {
          where: { 
            isActive: true,
            parentTaskId: null // Root tasks only
          },
          include: {
            assignees: {
              include: { user: true }
            },
            subtasks: {
              where: { isActive: true },
              include: {
                assignees: {
                  include: { user: true }
                }
              }
            }
          },
          orderBy: { position: 'asc' }
        }
      }
    });
  }
  
  // UPDATE - Move project between buckets
  async moveProject(projectId: string, toBucketId: string, newPosition: number) {
    return this.prisma.$transaction(async (tx) => {
      // Get current project
      const project = await tx.project.findUnique({
        where: { id: projectId }
      });
      
      if (!project) throw new Error('Project not found');
      
      // Update positions in source bucket
      await tx.project.updateMany({
        where: {
          bucketId: project.bucketId,
          position: { gt: project.position }
        },
        data: {
          position: { decrement: 1 }
        }
      });
      
      // Update positions in destination bucket
      await tx.project.updateMany({
        where: {
          bucketId: toBucketId,
          position: { gte: newPosition }
        },
        data: {
          position: { increment: 1 }
        }
      });
      
      // Move the project
      return tx.project.update({
        where: { id: projectId },
        data: {
          bucketId: toBucketId,
          position: newPosition
        }
      });
    });
  }
  
  // UPDATE - Project status
  async updateStatus(projectId: string, newStatus: string) {
    // Validate status transition
    const validTransitions = {
      planning: ['irb_submission'],
      irb_submission: ['irb_approved', 'planning'],
      irb_approved: ['data_collection'],
      data_collection: ['analysis'],
      analysis: ['manuscript'],
      manuscript: ['under_review'],
      under_review: ['published', 'manuscript'],
      published: [],
      on_hold: ['planning', 'data_collection', 'analysis'],
      cancelled: []
    };
    
    const project = await this.prisma.project.findUnique({
      where: { id: projectId }
    });
    
    if (!project) throw new Error('Project not found');
    
    const allowedStatuses = validTransitions[project.status] || [];
    if (!allowedStatuses.includes(newStatus) && newStatus !== 'on_hold' && newStatus !== 'cancelled') {
      throw new Error(`Cannot transition from ${project.status} to ${newStatus}`);
    }
    
    return this.prisma.project.update({
      where: { id: projectId },
      data: { status: newStatus }
    });
  }
  
  // DELETE - Soft delete with cascade
  async delete(projectId: string) {
    return this.prisma.$transaction(async (tx) => {
      // Soft delete all tasks
      await tx.task.updateMany({
        where: { projectId },
        data: { isActive: false }
      });
      
      // Soft delete project
      return tx.project.update({
        where: { id: projectId },
        data: { isActive: false }
      });
    });
  }
  
  // Helper - Create default tasks
  private async createDefaultTasks(tx: any, projectId: string, projectType: string) {
    const taskTemplates = {
      rct: [
        'Develop protocol',
        'Submit to IRB',
        'Site initiation',
        'Recruit participants',
        'Conduct intervention',
        'Collect data',
        'Analyze results',
        'Write manuscript'
      ],
      ehr_study: [
        'Define cohort criteria',
        'Submit IRB',
        'Request data pull',
        'Clean data',
        'Statistical analysis',
        'Write manuscript'
      ],
      ai_llm: [
        'Define research question',
        'Prepare dataset',
        'Develop model',
        'Validate model',
        'Test deployment',
        'Document findings'
      ]
    };
    
    const tasks = taskTemplates[projectType] || [];
    
    for (let i = 0; i < tasks.length; i++) {
      await tx.task.create({
        data: {
          projectId,
          title: tasks[i],
          position: i,
          createdById: this.userId
        }
      });
    }
  }
}
4. Task CRUD Service
typescript// services/task.service.ts
export class TaskService extends BaseService {
  
  // CREATE - New task for a project
  async create(data: CreateTaskInput) {
    // Validate project access
    const project = await this.prisma.project.findFirst({
      where: {
        id: data.projectId,
        members: {
          some: {
            userId: this.userId
          }
        }
      }
    });
    
    if (!project) {
      throw new Error('Project not found or access denied');
    }
    
    // Get position
    const lastTask = await this.prisma.task.findFirst({
      where: { 
        projectId: data.projectId,
        parentTaskId: data.parentTaskId || null
      },
      orderBy: { position: 'desc' }
    });
    
    const position = (lastTask?.position ?? -1) + 1;
    
    return this.prisma.task.create({
      data: {
        ...data,
        position,
        createdById: this.userId,
        assignees: data.assigneeIds ? {
          create: data.assigneeIds.map(userId => ({
            userId
          }))
        } : undefined
      },
      include: {
        assignees: {
          include: { user: true }
        },
        project: true
      }
    });
  }
  
  // READ - Get tasks for a project
  async getProjectTasks(projectId: string) {
    return this.prisma.task.findMany({
      where: {
        projectId,
        isActive: true,
        parentTaskId: null // Root tasks only
      },
      include: {
        assignees: {
          include: { user: true }
        },
        subtasks: {
          where: { isActive: true },
          include: {
            assignees: {
              include: { user: true }
            }
          },
          orderBy: { position: 'asc' }
        }
      },
      orderBy: { position: 'asc' }
    });
  }
  
  // UPDATE - Update task status
  async updateStatus(taskId: string, newStatus: string) {
    const task = await this.prisma.task.update({
      where: { id: taskId },
      data: { 
        status: newStatus,
        completedAt: newStatus === 'completed' ? new Date() : null,
        completedById: newStatus === 'completed' ? this.userId : null
      }
    });
    
    // If task completed, check if all tasks are done
    if (newStatus === 'completed') {
      const incompleteTasks = await this.prisma.task.count({
        where: {
          projectId: task.projectId,
          isActive: true,
          status: { not: 'completed' }
        }
      });
      
      // Could trigger project status update here
      if (incompleteTasks === 0) {
        // All tasks completed
      }
    }
    
    return task;
  }
  
  // UPDATE - Reorder tasks
  async reorderTasks(projectId: string, taskOrder: string[]) {
    const updates = taskOrder.map((taskId, index) =>
      this.prisma.task.update({
        where: { id: taskId },
        data: { position: index }
      })
    );
    
    return this.prisma.$transaction(updates);
  }
  
  // CREATE - Add subtask
  async createSubtask(parentTaskId: string, data: CreateSubtaskInput) {
    const parentTask = await this.prisma.task.findUnique({
      where: { id: parentTaskId }
    });
    
    if (!parentTask) throw new Error('Parent task not found');
    
    return this.create({
      ...data,
      projectId: parentTask.projectId,
      parentTaskId
    });
  }
  
  // DELETE - Soft delete with subtasks
  async delete(taskId: string) {
    return this.prisma.$transaction(async (tx) => {
      // Delete all subtasks
      await tx.task.updateMany({
        where: { parentTaskId: taskId },
        data: { isActive: false }
      });
      
      // Delete task
      return tx.task.update({
        where: { id: taskId },
        data: { isActive: false }
      });
    });
  }
}
5. Kanban View Component
tsx// components/views/KanbanBoard.tsx
export function KanbanBoard({ labId }: { labId: string }) {
  const { data: buckets } = useQuery(
    ['buckets', labId],
    () => bucketService.getBucketsWithProjects(labId)
  );
  
  const moveProject = async (projectId: string, toBucketId: string, position: number) => {
    await projectService.moveProject(projectId, toBucketId, position);
    queryClient.invalidateQueries(['buckets', labId]);
  };
  
  return (
    <DragDropContext onDragEnd={handleDragEnd}>
      <div className="kanban-board">
        {buckets?.map(bucket => (
          <Droppable key={bucket.id} droppableId={bucket.id}>
            {(provided, snapshot) => (
              <BucketColumn
                ref={provided.innerRef}
                {...provided.droppableProps}
                isDraggingOver={snapshot.isDraggingOver}
                style={{ backgroundColor: bucket.color + '10' }}
              >
                <BucketHeader>
                  <BucketName>{bucket.name}</BucketName>
                  <ProjectCount>{bucket.projects.length}</ProjectCount>
                </BucketHeader>
                
                <ProjectList>
                  {bucket.projects.map((project, index) => (
                    <Draggable 
                      key={project.id} 
                      draggableId={project.id} 
                      index={index}
                    >
                      {(provided, snapshot) => (
                        <ProjectCard
                          ref={provided.innerRef}
                          {...provided.draggableProps}
                          {...provided.dragHandleProps}
                          isDragging={snapshot.isDragging}
                        >
                          <StatusIndicator status={project.status} />
                          <ProjectName>{project.name}</ProjectName>
                          {project.oraNumber && (
                            <ORABadge>{project.oraNumber}</ORABadge>
                          )}
                          
                          <ProjectMeta>
                            <StudyType>{project.studyType}</StudyType>
                            {project.fundingSource && (
                              <FundingBadge>{project.fundingSource}</FundingBadge>
                            )}
                          </ProjectMeta>
                          
                          <TeamSection>
                            {project.members.map(member => (
                              <Avatar 
                                key={member.userId}
                                user={member.user}
                                size="sm"
                              />
                            ))}
                          </TeamSection>
                          
                          <TaskProgress>
                            {project.tasks.filter(t => t.status === 'completed').length}/
                            {project.tasks.length} tasks
                          </TaskProgress>
                        </ProjectCard>
                      )}
                    </Draggable>
                  ))}
                  {provided.placeholder}
                </ProjectList>
                
                <AddProjectButton bucketId={bucket.id} />
              </BucketColumn>
            )}
          </Droppable>
        ))}
        
        <AddBucketButton labId={labId} />
      </div>
    </DragDropContext>
  );
}
6. Project Detail View with Tasks
tsx// components/views/ProjectDetail.tsx
export function ProjectDetail({ projectId }: { projectId: string }) {
  const { data: project } = useQuery(
    ['project', projectId],
    () => projectService.getProjectWithTasks(projectId)
  );
  
  return (
    <ProjectContainer>
      <ProjectHeader>
        <BackButton onClick={() => router.back()} />
        <ProjectInfo>
          <h1>{project.name}</h1>
          <ProjectMetadata>
            <ORANumber>{project.oraNumber}</ORANumber>
            <Status>{project.status}</Status>
            <Bucket>{project.bucket.name}</Bucket>
          </ProjectMetadata>
        </ProjectInfo>
      </ProjectHeader>
      
      <ProjectTeam>
        <h3>Team Members</h3>
        <MemberList>
          {project.members.map(member => (
            <MemberCard key={member.userId}>
              <Avatar user={member.user} />
              <MemberInfo>
                <Name>{member.user.firstName} {member.user.lastName}</Name>
                <Role>{member.role}</Role>
              </MemberInfo>
            </MemberCard>
          ))}
        </MemberList>
        <AddMemberButton projectId={projectId} />
      </ProjectTeam>
      
      <TasksSection>
        <TasksHeader>
          <h3>Tasks</h3>
          <AddTaskButton projectId={projectId} />
        </TasksHeader>
        
        <TaskList>
          {project.tasks.map(task => (
            <TaskItem key={task.id}>
              <TaskCheckbox 
                checked={task.status === 'completed'}
                onChange={() => toggleTaskStatus(task.id)}
              />
              <TaskContent>
                <TaskTitle>{task.title}</TaskTitle>
                {task.dueDate && (
                  <DueDate date={task.dueDate} />
                )}
                <Assignees>
                  {task.assignees.map(a => (
                    <Avatar 
                      key={a.userId} 
                      user={a.user} 
                      size="xs" 
                    />
                  ))}
                </Assignees>
              </TaskContent>
              
              {task.subtasks.length > 0 && (
                <SubtaskList>
                  {task.subtasks.map(subtask => (
                    <SubtaskItem key={subtask.id}>
                      <TaskCheckbox 
                        checked={subtask.status === 'completed'}
                        onChange={() => toggleTaskStatus(subtask.id)}
                      />
                      <SubtaskTitle>{subtask.title}</SubtaskTitle>
                    </SubtaskItem>
                  ))}
                </SubtaskList>
              )}
            </TaskItem>
          ))}
        </TaskList>
      </TasksSection>
    </ProjectContainer>
  );
}
Key Features of This Structure:

Strict Hierarchy:

Every Project MUST belong to a Bucket
Every Task MUST belong to a Project
Subtasks belong to parent Tasks


Lab Member Access:

Members see buckets in their lab
Can be assigned to projects
Can be assigned to tasks


Clean CRUD Operations:

Create: Add at each level with proper validation
Read: Efficient queries with includes
Update: Status changes, reordering, assignments
Delete: Soft deletes with cascade


Kanban Functionality:

Drag projects between buckets
Visual progress tracking
Team member avatars


Simple & Focused:

No complex integrations
File links only
Research-specific workflows



This structure ensures your Bucket → Project → Task hierarchy works smoothly for all lab members while maintaining the clean, dark UI you've designed.